#!/usr/bin/env python

from argparse import ArgumentParser
import os, sys, datetime
import subprocess
from os.path import dirname, abspath

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def main():
  parser = ArgumentParser(description='SPATIAL')
  parser.add_argument('app', type=str, help='name of application to run')
  parser.add_argument('--DSE', dest='dse', action='store_true',default=False, help='enables design space exploration')

  parser.add_argument('-q', dest='quiet', action='store_true',default=False,help='disables background logging')
  parser.add_argument('-v', dest='verbose', action='store_true',default=False,help='enables verbose printout')

  parser.add_argument('--scala', dest='scala', action='store_true', default=False, help='enables scala generation')
  parser.add_argument('--chisel', dest='chisel', action='store_true', default=False, help='enables chisel generation')
  parser.add_argument("--cpp", dest="cpp", action="store_true", default=False, help="enables cpp generation")
  parser.add_argument("--fpga", dest="fpga", default="Default", help="Set name of FPGA target")

  # TODO: It doesn't make sense to have this as an option if the action and default are the same
  parser.add_argument('--naming', dest='naming', action='store_true', default=True, help='generates the debug name for all syms, rather than "x${s.id}" only')
  parser.add_argument('--tree', dest='tree', action='store_true', default=True, help='enables logging of controller tree for visualizing app structure')

  parser.add_argument('--debug', dest='debug', action='store_true', default=False, help='enables logging of compiler')
  parser.add_argument("--dot", dest="dot", action="store_true", default=False, help="enables dot generation")
  parser.add_argument("--outdir", dest="outdir", default="", help="location of output dir, relative to ${SPATIAL_HOME}.  Default is gen/<appname>")
  parser.add_argument("--multifile", dest="multifile", default=4, help="Aggressiveness for splitting generated HW code in many files. 0 = no splitting or scoping, 1 = no splitting but yes scoping on inner pipes, 2 = no splitting but yes scoping everywhere, 3 <DEPRECATED> = splitting for inner pipes only, 4 = all blocks")
  parser.add_argument("--emission", dest="emission", default=0, help="Conservativeness when emitting nodes.  0 = crash when emitNode is undefined (release mode), 1 = warn when undefined, 2 = warn when undefined and report when node matched but outside backend rules")
  parser.add_argument("--regression_cp", dest="cp_reg", default="", help="Temporary fix for regression testing not using the correct classpath")


  parser.add_argument("--clean", dest="clean", action="store_true", default=False, help="clean generate directory before compilation")
# # Plasticine work
# parser.add_argument('--CGRA+', dest='allCGRA', action="store_true", default=False, help="enable ALL PIR features")
# parser.add_argument('--CGRA*', dest='dseCGRA', action="store_true", default=False, help="enable ALL PIR features")

# parser.add_argument('--pdse', dest='pdse', action="store_true", default=False, help="enable CGRA DSE")
# parser.add_argument('--CGRA', dest='cgra', action='store_true', default=False, help='enables PIR generation')
# parser.add_argument('--pdebug', dest='pir_debug', action='store_true', default=False, help='enables PIR debugging output')
# parser.add_argument('--split', dest='split', action="store_true", default=False, help="enable PIR CU splitting")

# parser.add_argument("--sIn", type=int, help="set number of scalar inputs / CU")
# parser.add_argument("--sbus", type=int, help="set number of scalars / bus")
# parser.add_argument("--vIn", type=int, help="set number of vector inputs / CU")
# parser.add_argument("--vOut", type=int, help="set number of vector outputs / CU")
# parser.add_argument("--comp", type=int, help="set number of compute-only stages / CU")
# parser.add_argument("--rw", type=int, help="set number of read/write enabled stages / CU")
# parser.add_argument("--mems", type=int, help="set number of SRAMs / CU")

  SPATIAL_HOME = os.getenv("SPATIAL_HOME", dirname(dirname(abspath(__file__))))
  print( dirname(dirname(abspath(__file__))))
  JAVA_HOME = os.getenv("JAVA_HOME", "")
  java_opts = os.getenv("JAVA_OPTS", "")

  if SPATIAL_HOME == "":
    print('SPATIAL_HOME is undefined.')
    exit(1)

  (opts, args) = parser.parse_known_args()

  # if opts.allCGRA or opts.dseCGRA:
  #   opts.cgra = True
  #   opts.pir_debug = True
  #   opts.split = True
  #   opts.debug = True

  # if opts.dseCGRA:
  #   opts.pdse = True

  # if opts.pir_debug: java_opts = java_opts + " -Dspatial.pirdebug=true"
  # if opts.cgra:      java_opts = java_opts + " -Dspatial.cgra=true"
  # if opts.pdse:      java_opts = java_opts + " -Dspatial.pdse=true"
  # if opts.split:     java_opts = java_opts + " -Dspatial.split=true"


  if opts.quiet:     java_opts = java_opts + " -Dargon.verbosity=0"
  elif opts.verbose: java_opts = java_opts + " -Dargon.verbosity=2"

  if opts.chisel:
      opts.cpp = True
      java_opts = java_opts + " -Dspatial.chisel=true"

  if opts.naming: java_opts = java_opts + " -Dspatial.naming=true"
  if opts.tree:   java_opts = java_opts + " -Dspatial.tree=true"
  if opts.dse:    java_opts = java_opts + " -Dspatial.dse=true"
  if opts.debug:  java_opts = java_opts + " -Dspatial.log=true"
  if opts.dot:    java_opts = java_opts + " -Dspatial.dot=true"
  if opts.scala:  java_opts = java_opts + " -Dspatial.scala=true"
  if opts.cpp:    java_opts = java_opts + " -Dspatial.cpp=true"
  if opts.clean:  java_opts = java_opts + " -Dargon.clearGen=true"


  if opts.outdir != "":
    # Clean outdir
    #os.system("rm -rf " + os.path.join(SPATIAL_HOME, opts.outdir) + "/*")
    java_opts = java_opts + " -Dargon.out=" + os.path.join(SPATIAL_HOME, opts.outdir)

  java_opts = java_opts + " -Dargon.name=" + opts.app
  java_opts = java_opts + " -Dargon.emission=" + "%s" % opts.emission
  java_opts = java_opts + " -Dspatial.fpga=" + opts.fpga
  java_opts = java_opts + " -Dargon.multifile=" + "%s" % opts.multifile
  java_opts = java_opts + " -Dspatial.multifile=" + "%s" % opts.multifile
  #java_opts = java_opts + " -Xms128m"
  #java_opts = java_opts + " -Xmx1024m"

  # Add classpaths
  # scala_major_id = os.system('sbt scala-version')
  scala_major_id = "scala-2.12"  
  dsljar = "spatial/target/" + scala_major_id + "/spatial-lang.jar" + os.pathsep
  appsjar = "apps/target/" + scala_major_id + "/apps.jar" + os.pathsep

  old_cp = os.getenv("CLASSPATH", "")
  cp = " -cp "
  cp = cp + old_cp + os.pathsep
  cp += opts.cp_reg + appsjar

  java_opts = java_opts + cp

  if JAVA_HOME != "":
    JAVA_HOME = JAVA_HOME + "/bin/"

  ## Run Spatial
  java_cmd = JAVA_HOME + "java " + java_opts + " " + opts.app + " " + " ".join(args)
  #print(java_cmd)

  ecode = os.system(java_cmd)

  if ecode != 0:
    print("[" + bcolors.FAIL + "error" + bcolors.ENDC + "] Spatial compilation failed")

if __name__ == "__main__":
    main()
